# Introduction - 1/2 page - small review before finalisation
What is this project? This report presented is to describe the overview, design, and
implementation of an optimised scheduling system compared to it's stage 1 counterpart (found here). The goal of the optimisation is the reduce the average turn around time of job scheduled when compared to the 4 baseline scheduling algorithms being First-Capable, First-Fit, Best-Fit, and Worst-Fit. The results generated by the first script found in this project will highlight the benefits and drawback of the optimised algorithm when compared to each of the 4 baseline algorithms; First-Capable, Fit-Fit, Best-Fit, Worst-Fit.

At itâ€™s core, a distributed system is a system that has various components which are spread across a network. This provides many advantages such as efficiency and redundancy, it also introduces complications such as an increased complexity, synchronisation and replication issues.

In a distributed system, the load is distributed across multiple machines to achieve fast and more reliable results. Each distributed system requires a component to orchestrate and distribute each request.

This project acts as an orchestrating component of a distributed system.

The goal for this project is to have a client which connects to the server, and makes sceduling decisions that result in an optimised turn around time in the processing of each job when compared to the 4 baseline algorithms.

# Problem definition - 1/2 page - small review before finalisation
the baseline algorithms all work differently, which leads to certain advantages and drawbacks depending on the goal of the algorithm and the workload provided.

First-capable works by scheduling jobs to the first machine capable of handing the job, ignoring the number of jobs already in queue for that machine. This works out to be efficient in terms of cost, but inefficient in terms of speed because of the long queue time.

First-fit works by allocating the job to the first machine that is capable of handling the job immediately, this works out to be efficient in terms of speed, but can lead to poor resource utilisation as it can leave un-used cores on each machine. 

Best-fit allocates the job to a machine which is the least sufficient among the available machines, but may perform poorer than other algorithms in some cases as it can leave cores that can't be used since jobs cannot be broken up and handled separately.

Worst-fit allocates the job to a machine which is the most sufficient among the available machines, resulting in more compute resources left on the machine in anticipation for the next job, but it leads to an increased cost and poor utilisation if the remaining jobs require more than the leftover resources on the machine.

The objective of this project is design an algorithm that reduces average turnaround time when compared to each of these baseline algorithms without sacrificing too much of the other performance metrics such as resource utilisation and server rental cost.

# Algorithm description - 1 page - TODOS: diagram
The algorithm designed as part of this project is able to produce shorter turn-around times for job scheduling than all 4 of the baseline algorithms in certain circumstances by combining the methods used in first-capable and best-fit.

This is demonstrated most effectively in scheduling configurations where there are N servers currently processing jobs at full capacity before another job comes in. The job is scheduled to the least capable server that can handle the job once it becomes available.

(draw diagram here)

When a new job comes in, the algorithm perfroms a GETS CAPABLE command based on the job and sorts the response by estimated job wait time per server in ascending order. The algorithm then loops over the sorted list, searching for the first server that can handle the job immediately and schedules the job with that server if found. If there is no server that can handle the job immediately, the job is queued for the server that is least sufficient in handling the job in terms of core count.

This can be most easily observed in this configuration (see here).

The average turnaround-time produced by this algorithm could be further optimised by performing a calculation before moving to least capable server to see WHEN the next preferred server will become free and either still schedule the job or migrate the currently running job is it recently started.

# Implementation - 1/2 page - small review before finalisation
As highlighted in the stage 1 report, stage 2 still makes use of the core componenents such as the ConfigDataLoader, ClientServerConnection, Orchestrator, SimulatedSystem, SimulatedServer and Job classes to handle the client-server connection, data processing and manipulation, and fundamental scheduling functionality. 

## Data structures
The biggest change introduced in stage 2 is the adoption of using the Java Collections and Comparator libraries to help manage the sorting of ArrayLists.

Sorted Arraylists - Utilising the Java Collections and Comparator libraries to sort SimulatedServers based on key metrics such as core count, estimated job wait time, etc. 

## Libraries
In addition to the libraries highlighted in the stage 1 report, this project employs the use of the following classes provided by Java 1.8:
1. Collections - The SimulatedSystem employs the use of the Java Collections library to sort lists of SimulatedServers.
2. Comparator - The SimulatedSystem employs the use of the Java Comparator library to compare SimulatedServers whilst performing sorting operations.

# Evaluation - 2 pages
- simulation setup including test cases/configurations, results, comparisons (with
FF, BF, WF and FC) and discussion including pros and cons of the algorithm. Use figures and tables
effectively and be space conscious.

-- simulation setup
A simulation can be run by running the `{cpu_architecture}_test.bash` script from the `./scripts` directory.
- aarch64 command
`aarch64_test.bash`

-- x86 command
`x86_test.bash`

Running the appropriate script for the architecture of the machine used will run the algorithm against all of the test configurations. Once complete, a comparison of the results between the newly designed algorithm and the 4 baseline algorithms when run with each configuration will be displayed, so successful optimisation being highlighted the following colors:
- green (if the result is more efficient than all 4 of the baseline algoritms)
- orange (if the result is more efficient than at least one of the 4 baseline algorithms)
- red (if the result is less efficient than the least efficient of the baseline algorithms)

Additonally, we can observe an average of how each of the algorithms performed for each metric across all configurations. 

(insert screenshot here)

By running the tests, we can observe that the average turnaround time is greatly reduced in comparision to the 4 baseline algorithms, with fastest algorithm on average being first-fit at an average of 1803.50. The algorithm designed in this project is able to achieve an average turnaround time of 1486.17. Noting that the gap between the fastest baseline and this algorithm is not always consistently as substantial, we can see this by observing the results from config50-short-med and config-20-long-low where the advantage is marginal. We also can observe that with certain configurations the new algorithm is less efficient than the baselines in terms of rental costs. However, the algorithm is still more efficient in terms of rental cost on average when compared to Worst-fit.

-- Comparisons against baseline algorithms
- First-Capable
When compared directly to the first-capable algorithm, the new algorithm displays a substantial decrease in turnaround time, which is consistent with our expectations as first-capable will not use as many servers and as a result, cause longer queue times. Due to the fact that first-capable will use fewer servers, those servers are better utilised in comparison to the new algorithm, which is also observable in the results. Additionally, with fewer servers being used and better utilisation, FC is far superior in terms of rental costs when compared against all other baseline algorithms and the new algorithm.

(draw a table here showing FC and our new algo)
(headings: FC, New Algorithm)
(row: Turnaround time, 246382.78, 1486.17)
(row: Resource Utilisation, 94.37, 63.78)
(row: Total Rental Cost, 379.20, 643.85)

Pros of our algo compared to FC: much faster
Cons: poorer utilisation, higher rental costs

- First-Fit
Compared to the first-fit baseline algorithm, the new algorithm displays a sufficient decrease in turnaround time on average. However, when breaking down the results per configuration, we can see the the advantage is marginal in certain configurations, this is because the new algorithm uses a similar method to schedule a job if there are multiple available servers to handle the job immediately, which is can produce similar results to first-fit if the configuration creates the circumstance. Due to this consistency, the average results for resource utilisation does not show a substantial difference between first-fit and the new algorithm. Observing the results for the average rental cost, we can see that first-fit is cheaper on average at the cost of a slightly longer turnaround time when compared to the new algorithm.

(draw a table here showing FF and our new algo)
(headings: FC, New Algorithm)
(row: Turnaround time, 1803.50, 1486.17)
(row: Resource Utilisation, 63.30, 63.78)
(row: Total Rental Cost, 638.18, 643.85)

Pros of our algo compared to FF: slightly faster at the cost of a slightly higher rental cost.

- Best-Fit
As with first-fit, our new algorithm display a sufficient descrease in turnaround time on average compared to best-fit, but we continue to see marginal advantages in certain configurations when the results are broken down. This is also consitent with our expectations due to the fact that the new algorithm employs some mechanisms from best-fit to achieve it's goal. We increase the changes of seeing reduced turnaround time optimisations for configurations where there are no available servers to handle the job, which results in the job being scheduled with the least sufficient server, much like best-fit. A marginally improved resource utilisation and a slight increase in rental cost can be observed on average in best-fit, which is expected as the slightly higher cost is a result from using the hybrid approach in the new algorithm to achieve lower turnaround times.

(draw a table here showing BF and our new algo)
(headings: BF, New Algorithm)
(row: Turnaround time, 1866.72, 1486.17)
(row: Resource Utilisation, 60.72, 63.78)
(row: Total Rental Cost, 636.89, 643.85)

Pros of our algo compared to BF: similar to the advantages and disadvantages of FC, slightly faster at the cost of a slightly higher rental cost.

- Worst-Fit
The new algorithm displays superior efficienies in average turnaround time when compared to best-fit, this is further justified when we break down the results from each simulation, we observed that the new algorithm is consistently able to produce faster turnaround times for every simulation. Resource utilisation is observed to be improved in worst-fit, while gaining an improvement on average rental cost in the new algorithm. 

(draw a table here showing BF and our new algo)
(headings: WF, New Algorithm)
(row: Turnaround time, 19609.94, 1486.17)
(row: Resource Utilisation, 68.79, 63.78)
(row: Total Rental Cost, 665.09, 643.85)

Pros of our algo compared to WF: much faster, slightly cheaper, at the cost of a marginal decrease in resource utilisation.

# Conclusion - 1/4 page - very last
- summary + what I have found and what I suggest.
New algo is very fast while still being cheaper than the most expensive on average. 

# References - 1/4 page - very last
- including project git repository link, e.g., GitHub