# Introduction - 1/2 page - small review before finalisation
What is this project? This report presented is to describe the overview, design, and
implementation of an optimised scheduling system compared to it's stage 1 counterpart (found here). The goal of the optimisation is the reduce the average turn around time of job scheduled when compared to the 4 baseline scheduling algorithms being First-Capable, First-Fit, Best-Fit, and Worst-Fit. The results generated by the first script found in this project will highlight the benefits and drawback of the optimised algorithm when compared to each of the 4 baseline algorithms.

At itâ€™s core, a distributed system is a system that has various components which
are spread across a network. This provides many advantages such as efficiency and
redundancy, it also introduces complications such as an increased complexity, synchro-
nisation and replication issues.

In a distributed system, the load is distributed across multiple machines to achieve
fast and more reliable results. Each distributed system requires a component to or-
chestrate and distribute each request.

This project acts as an orchestrating component of a distributed system.

The goal for this project is to have a client which connects to the server, and makes sceduling decisions that result in an optimised turn around time in the processing of each job when compared to the 4 baseline algorithms.

# Problem definition - 1/2 page - small review before finalisation
the baseline algorithms all work differently, which leads to certain advantages and drawbacks depending on the goal of the algorithm and the workload provided.

First-capable works by scheduling jobs to the first machine capable of handing the job, ignoring the number of jobs already in queue for that machine. This works out to be efficient in terms of cost, but inefficient in terms of speed because of the long queue time.

First-fit works by allocating the job to the first machine that is capable of handling the job immediately, this works out to be efficient in terms of speed, but can lead to poor resource utilisation as it can leave un-used cores on each machine. 

Best-fit allocates the job to a machine which is the least sufficient among the available machines, but may perform poorer than other algorithms in some cases as it can leave cores that can't be used since jobs cannot be broken up and handled separately.

Worst-fit allocates the job to a machine which is the most sufficient among the available machines, resulting in more compute resources left on the machine in anticipation for the next job, but it leads to an increased cost and poor utilisation if the remaining jobs require more than the leftover resources on the machine.

The objective of this project is design an algorithm that reduces average turnaround time when compared to each of these baseline algorithms without sacrificing too much of the other performance metrics such as resource utilisation and server rental cost.

# Algorithm description - 1 page - TODOS: diagram
- the schedule, description and discussion
The algorithm designed as part of this project is able to produce shorter turn-around times for job scheduling than all 4 of the baseline algorithms in certain circumstances by combining the methods used in first-capable and best-fit.

This is demonstrated most effectively in scheduling configurations where there are N servers currently processing jobs at full capacity before another job comes in. The job is scheduled to the least capable server that can handle the job once it becomes available.

(draw diagram here)

- provide a simple example scheduling scenario
When a new job comes in, the algorithm attempts to find an available server that can handle the job immediately and schedules the job with that server if found. If there is no server that can handle the job immediately, the job is queued for the server that is least sufficient in handling the job in terms of core count.

- including a sample configuration
This can be most easily observed in this configuration (see here).

# Implementation details including data structures - 1/2 page - small review before finalisation
As highlighted in the stage 1 report, stage 2 still makes use of the core componenents such as the ConfigDataLoader, ClientServerConnection, Orchestrator, SimulatedSystem, SimulatedServer and Job classes to handle the client-server connection, data processing and manipulation, and fundamental scheduling functionality. 

## Data structures
The biggest change introduced in stage 2 is the adoption of using the Java Collections and Comparator libraries.

Sorted Arraylists - Utilising the Java Collections and Comparator libraries to sort SimulatedServers based on key metrics such as core count, estimated job wait time, etc. 

## Libraries
In addition to the libraries highlighted in the stage 1 report, this project employs the use of the following classes provided by Java 1.8:
1. Collections - The SimulatedSystem employs the use of the Java Collections library to sort lists of SimulatedServers.
2. Comparator - The SimulatedSystem employs the use of the Java Comparator library to compare SimulatedServers whilst performing sorting operations.

# Evaluation - 2 pages - sunday
- simulation setup including test cases/configurations, results, comparisons (with
FF, BF, WF and FC) and discussion including pros and cons of the algorithm. Use figures and tables
effectively and be space conscious.

A simulation can be run by running the `compile+test.bash` script from the `./scripts` directory. This will run the project against all of the test comfigurations and compare the results between the newly designed algorithm and the 4 baseline algorithms.

The fact that the algorithm does not migrate jobs between servers if the potential server has just started processing a long-running job can lead to longer queue times given the specific circumstances. 

We could make it faster by allocating the job to not the least capable, but to the server that will be available the soonest.

# Conclusion - 1/4 page - sunday
- summary + what I have found and what I suggest.

# References - 1/4 page - sunday
- including project git repository link, e.g., GitHub