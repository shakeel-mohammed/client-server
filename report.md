5 PAGES MAX
1. Introduction (1/2 page) - done
    - What is this project? - done
        - briefly explain distributed systems, breifly explain ds-sim, explain the goal of this project - done
2. System Overview (1/2 page) - done
    - high-level description of the system, include a diagram to show overall flow - need to add diagram
    - be sure to talk about how ds-sim works - done
    - talk about the protocol - done
3. Design (1 page) - thursday - nearly done
    - include design philosophy (i wanted a design that was easily controlled and extended to support future goals) - done
    - talk about the alogrithm (and how the client can be extended to support more algorithms) - done
    - considerations - done
    - constraints - done
    - functionality of each component on the client-side - done
    - talk about each class - done
4. Implementation (2 pages) - done
    - technologies, libraries, data structures used [in-built Java Properties, ArrayList, DataInputStream, DataOutputStream, Socket] - done
    - talk about HOW YOU USED the components above - done
5. References - friday
    - project git repository link
    - sources
    - etc
    - make sure we use bibtex citations
        - make bibtex file
        - cite in main file
    e.g the java client employs comparable interface \cite []....


TODOS:
- find citation for Largest Round Robin - now
- create overleaf project and compile into .tex file - today
    - should include references
    - git repos
    - use bibtex citations
- diagram for system overview - tomorrow
- diagram for communication protocol - tomorrow
- run on a normal computer using instructions here - tomorrow

# Introduction
What is this project?
This report presented is to describe the overview, design, and implementation of a scheduling system that implements the Largest Round Robin algorithm whilst distributing jobs to servers in a simulated distributed system (provided by MQ University). The results generated by the use of this project are to be compared to a reference implementation (also provided by MQ University).

At it's core, a distributed system is a system that has various components which are spread across a network. This provides many advantages such as efficiency and redundancy, as well as introducing complications such as an increased complexity, synchonisation and replication. Example of a distributed system would be cloud computing (not all cloud computing is is an exmaple of distributed systems, you could just have one computer in the cloud), where thousands of computers can be used to handle complex tasks by breaking down jobs and handling them simulantously.

In a distributed system, the load is distributed across multiple machines to achieve results that are much faster and reliable than having one server that handles all requests. Each distributed system requires a mechanism to orchestrate and handle each request. This component is responsible for making scheduling decisions which may vary depending on the desired behaviour the algorithm.

This project acts as an orchestrating component of a distributed system.

What is the goal?
The goal for this project is to have a client (described below) which connects to the server (described below), receives jobs to be scheduled and makes scheduling decisions based on the desired algorithm (Largest Round Robin in this case). Once the server has run out of jobs to be processed, the client should gracefully disconnect from the server.


# System Overview 
The system is comprised of two main components:
1. the ds-sim Server (provided by MQ University) - the component intiates the request to process each job + the component that simulates the compute resources available.
2. the Client (this project) which is to be compared to the reference implementation (provided by MQ University) - the component that handles the request to process each job and selects compute resources on which to schedule jobs for processing.

### The ds-sim server
The ds-sim server (1) simulates a distributed system. It is responsible for initiating the request to process a job, as well as providing the simulated compute resources (servers) on which each job may potentially be run. The ds-sim server can be run with the following optional parameters:
- -c - this allows us to define a configuration file on which we want the simulated system to be based on. This file will contain the number and types of of servers and jobs. 
[list other options]


### The Client
The purpose of the client (2) is to select the most appropriate simulated server on which the job should be processed.

### Communication Protocol
The two components communicate via a Socket, which uses TCP at the network layer. See here \TODO cite[https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html]

\TODO [INSERT DIAGRAM HERE]

The protocol is as follows:
1. the ds-sim server is started, creates a simulated system based on the confile file passed in, and waits for incoming socket connections
2. the client is started and initiates a handshake with the server
3. server replies with HELO
4. client sends AUTH command
5. server accepts
6. the server writes information on the simulated system to a ds-system.xml file
6. in a loop, the following happens:
- the client sends REDY command
- the server responds with either:
    a. a new job
    b. a completed job
    c. an error
    d. a no new jobs command
- the client handles as follows:
    a. quries the server to find servers capable of handling the jobs (GETS CAPABLE command) and selects the correct server to handle the job based on the LLR algorithm.
    b. does not require handling
    c. the logs the error and stops the job scheduling process.
    d. this command will break the loop
7. once the loop is complete (no more jobs left to process), the client sends QUIT command
8. the server replies with QUIT
9. the connection is closed gracefully

# Design
The design must cater for the connection between the two main components; the server and the client, as well as break down the current state of the simulated ds-sim system at any one time to handle incoming jobs. The two main entities in ds-sim are Servers and Jobs. These are the entities that are used to make scheduling decisions.

### Servers
In a distrubuted system, a server is a compute resource equipped with its own CPU, memory, and disk. They can be either hardware/physical or vitual servers. In the case of the ds-sim system, each simulated server is virtual. They have the following attributes:
- server ID - a server identifier.
- server type - an identifier of server category.
- limit - the number of servers of a particular type.
- boot-up time - the time in seconds it takes for the server to boot.
- hourly rate - the hourly rental rate in dollars. The charge is calculated based on the amount of seconds the server was used for.
- cores - the number of CPU cores.
- memory - the amount of memory in MB.
- disk - the amount of disk space in MB.

### Jobs
In this context, a Job can represent a task, or a single linux process. They are to be seen as rigid. i.e. if a job have compute requirements of 2 Cores, 200MB of memory and 1GB of disk space, and will take 10 seconds to complete, scheduling it on a server with twice the amount of the required resources will not result in a faster completion time. It will still take 20 seconds to complete. Jobs have the following attributes:
- job ID - a job identifier.
- type - an identifier for job category.
- submit time - the submit time could either be the initial time a job was submitted, or when it was re-submitted in the case of jobs being pre-empted, killed, or failed.
- estimated run time - estimated based on the actual run time of a job.
- cores - the number of CPU cores required to process the job.
- memory - the amount of RAM in MB required to process the job.
- disk - the amount of disk space in MB required to process the job.

Processing information on each of these entities is crucial for our design to be able to make the correct scheduling decisions to achieve our goal: scheduling based on Largest Round Robin.

\TODO cite [could use a citation here]
What exactly is Largest Round Robin? How does it work?
A little bit about the Largest Round Robin algorithm. It works by scheduling jobs to servers that are of the type in the system have the highest number of cores. Eg, if there are a total of 5 servers: 1x supersilk (16 cores), 2x joon (12 cores), 2x juju (8 cores), the type of servers which the largest number of cores would be supersilk, even if at the time of job scheduling, there are more available cores on a joon server, as per largest round robin, the job should still be scheduled on the supersilk server. In this algorithm, all servers expect the ones of the largest type are ignored throughout the whole run.

The design achieves job scheduling by Largest Round Robin by the use of the following components:
## ConfigDataLoader
A singleton object that's primary purpose is to serve as a configuration parameter store. It reads key/value pairs from the config.properties file and makes those parameters available to our application. Our application is then able to change it's behaviour based on the specified configuration, without requiring to be re-compiled.

[table for the below]
Attributes:
props - A Java Properties object

Methods:
getInstance - returns the pre-initialized instance. If not already initialized, calling this method will initialize one and return the newly created instance.
get - returns a value based on the key provided

## ClientServerConnection
A singleton object with a primary purpose of to handling the socket connection between the client and the ds-sim server. It provides an interface for the rest of the application to send and recieve messages to the ds-sim server.

[table for the below]
Attributes:
socket
inputStream
outputStream
hostIp
hostPort
isHandshakeSuccessful

Methods:
setupConnection
getDataInputStream
getDataOutputStream
wasHandshakeSuccessful
getInstance
sendMessage - supports the use of a buffer passed into the sendMessage function, this will tell the object to expect a multi-line response and use the buffer to parse it. The class itself is not responsible for the initialisation of the buffer because the size of the buffer varies depending on the requirements of the component sending/receiving the message.
handshake
closeConnectionGracefully

## Orchestrator
The compomonent responsible for making scheduling decisions. It currently implements the Largest Round Robin algorithm. It can easily be extended to support additional alogrithms. The Orchestrator uses the methods provided by the SimulatedSystem, SimulatedServer, and Job classes to decide which scheduling decisions should be made.

[table for the below]
Attributes:
clientServerConnection
simulatedSystem
largestServerType
mostRecentlyUsedServer
algorithm

Methods:
run - public
runWithLargestRoundRobin - private

## SimulatedSystem
The component responsible for containing information on the simulated system which the ds-sim server provides. It provides information on the system as a swarm of servers. i.e. the largest type of server, list of servers, etc.

[table for the below]
Attributes:
configDataLoader
clientServerConnection
serverStore
largestServerType

Methods:
queryDSSim
refreshServerStore
getTypeOfLargestServer
getServerStore
getLargestServer
findNextServerByType
getNextServerById

## SimulatedServer
Each instance of this component represents one server which exists in the ds-sim server. It contains information on the type of server, number of cores, number of jobs running, etc.

[table for the below]
Attributes:
configDataLoader
clientServerConnection
serverType
serverID
state
currentStartTime
core
memory
disk
numWaitingJobs
numRunningJobs
jobList

Methods:
getID
getNumberOfCores
getServerType
scheduleJob
queryJobList

## Job
A Job object represents one job which has been sent to the client by the ds-sim server. It contains all of the attributes that define a job. Each job object also contains a method which can be used to generate a query that can be sent to the ds-sim server in order to query a list of servers capable of processing the job. 

[table for the below]
Attributes:
jobState
startTime
submitTime
jobID
estimatedRunTime
core
memory
disk

Methods:
getID
getCoresRequired
getMemoryRequired
getDiskRequired
isComplete
buildQueryForCapableServer

The following components allow the system to standardise the instantiation of a job object. This is because the ds-sim server is capable of providing job information in more than one format. e.g:
- response to LSTJ command
- response to REDY command
With the use of the two components below, we can correctly format the job information in multiple scenarios, and can add support for additional formats.

## JobInformationBuilder
Uses the builder pattern to construct and return a JobInformation object based on the format of the stringifed job provided (response to LSTJ vs REDY command)

[table for the below]
Attributes:
Same as Job class

Methods:
parseJobState - private
parseBasedOnNewJobString - private
parseBasedOnCompletedJobString - private
parseBasedOnListJobsResponse - private
build - public

## Job Information
A Job Information object contains the correctly mapped attributes of one job.

Our design also needs to be easily extendible to support additional algorithms in the future. This meant that these scheduling decisions should not be baked into each component, but rather, they should provide the tools for the task implementing the algorithm to make informed decisions. The decision making should be handled entirely by one component (the Orchestrator), and it should be extendable to allow for decisions based on different rules (more algorithms).


## Constraints
### Java Runtime
This project requires a Java 1.8 to be run, which can be downloaded by following the instructions here, [https://docs.datastax.com/en/jdk-install/doc/jdk-install/installOpenJdkDeb.html]

## Considerations
As per the ds-sim protocol, there are two methods by which a connecting client could retrieve information about the simulated system:
1. ds-system.xml file - once a client has connected and a handshake is successful, the ds-sim server will create a ds-system.xml file which contains information on the simulated system in an xml format. This can then be parsed by the client used to make scheduling decisions
2. GETS command - a client is able to query the ds-sim server for a list of servers (GETS AVAIL and GETS CAPABLE). This can be a complete exhaustive list containing all of the simulated servers that can eventually become available, or a more precise list of server capable of handing a job based on cpu, memory and disk, which are immediately available for use.

This design uses the GETS CAPABLE command to increase efficiency and search only for the servers that are capable of handling the particular job ready for processing. 


# Implementation
## Technologies
- Java 1.8 - Java is a programming language and computing platform first released by Sun Microsystems in 1995. It has evolved from humble beginnings to power a large share of today’s digital world, by providing the reliable platform upon which many services and applications are built. The project has been created using Java 1.8.
- Bash scripting to assist with compilation.

## Libraries
The java client employs the use of the following classes provided by Java 1.8:
### IO/Networking
- Socket - A socket is an endpoint for communication between two machines. The client/server connect via a Socket. This Socket connection is established and persisted throughout the entire run.
- DataInputStream - A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. The client/server connection employs a DataInputStream to read responses from the server.
- DataOutputStream - A data output stream lets an application write primitive Java data types to an output stream in a portable way. The client/server connection employs a DataOutputStream to send messages to the server.
- IOException - Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations. This error is thrown if the ClientServerConnection class encounters an I/O exception.
- File - An abstract representation of file and directory pathnames. The ConfigDataLoader employs the use of the java File class to create a File object, which represents the config.properties file. This object is then used to read each property.
- FileInputStream - A FileInputStream obtains input bytes from a file in a file system. The ConfigDataLoader employs the use of a FileInputStream to read each line from the config.properties file and store them.
- FileNotFoundException - Signals that an attempt to open the file denoted by a specified pathname has failed. This error will be thrown if the config.properties file cannot be found. 

### Utils
- Properties - The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. The ConfigDataLoader employs the user of a Properties object to presist the key/value pairs provided in the config.properties file.

### Data Structures
- ArrayList - A resizable-array implementation of the List interface. Java Arraylists are utilised by the SimulatedSystem class to keep track of the SimulatedServers within the system, as well as the SimulatedServer class to keep track of the Jobs relating to the SimulatedServer.

## Job Scheduling
The implementation as per the ds-sim protocol and LRR is as follows:
1. the main.java file initializes the Config Data Store (which is then available pre-initialized to any other objects)
2. the main.java file initializes the Client Server Connection (which is then available pre-initialized to any other objects). Once created, the handshake process between the client and server is started 
3. the main.java file initializes the Orchestrator, which is passed the desired algorithm as an input parameter
4. the Orchestrator initializes a new DistributedSystem with no servers in it.
5. If the handshake process has been successful, the main.java file calls the .run() function on the orchestrator
6. the orchestrator object checks which algorithm it was configured with, and interally call it's runWithLargestRoundRobin() function
7. in a loop, the orchestrator.runWithLargestRoundRobin() function issues a REDY command to the server
8. the server responds with one of the following:
    a. JOBN
    b. JCPL
    c. NONE
9. the orchestrator does one of the follow depending on the above response:
    a. creates a new job object from the response
    b. creates a new job object from the response
    c. goes to step 19.
10. the orchestrator checks if the job has been completed. If the job has been completed, a new REDY command is issued to the server and the above cycle continues until either a job this is not completed is sent, or a NONE response is recieved.
11. the orchestrator uses the newly created job to construct a query to find the servers capable of processing that job
12. the distributedSystem.queryDSSim method is called to fill the system with capable servers
13. the distributedSystem.getTypeOfLargestServer method is called to find the type of server that contains the highest number of cores within the system
14. the distributedSystem.findNextServerByType method is called with the largest server type and most recently used server as input parameters to determine which server should be selected on which to schedule the job for processing
15. a new SimulatedServer object is instantiated from the server that was returned by the distributedSystem.findNextServerByType method
16. the SimulatedServer.scheduleJob method is called with the JobId as the input parameter to schedule the job on the found server.
17. the found server is saved as the most recently used server.
18. goes back to step 7.
19. breaks out of the loop and returns the thread back to the main.java file where the connection is ended gracefully.

## How to run 
### Compile
it comes pre-compiled, but the compile.bash script can be used to compile if required. From the main directory, run "bash scripts/compile.bash". This will compile the files in the /src directory and create or overwrite the files in the /compiled directory.

### To run
Navigate to the 'config.properties' file and observe the key/values pairs. The host IP, port, algorithm (currently, only supports llr) are configurable from this file. There is also a value for 'buffer_for_record_length' which is the amount of bytes added to the calculated length of buffers used throughout the client. 

Navigate to the /compiled directory and run 'java Main'.

# References