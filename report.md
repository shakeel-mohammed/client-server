5 PAGES MAX
1. Introduction (1/2 page) - done
    - What is this project? - done
        - briefly explain distributed systems, breifly explain ds-sim, explain the goal of this project - done
2. System Overview (1/2 page)
    - high-level description of the system, include a diagram to show overall flow - need to add diagram
    - be sure to talk about how ds-sim works - halfway
    - talk about the protocol - halfway
3. Design (1 page) - thursday
    - include design philosophy (i wanted a design that was easily controlled and extended to support future goals)
    - talk about the alogrithm (and how the client can be extended to support more algorithms)
    - considerations
    - constraints
    - functionality of each component on the client-side
    - talk about each class
4. Implementation (2 pages) - friday
    - technologies, libraries, data structures, (invariants?) used
    - talk about HOW YOU USED the components above
5. References - friday
    - project git repository link
    - sources
    - etc
    - make sure we use bibtex citations
        - make bibtex file
        - cite in main file
    e.g the java client employs comparable interface \cite []....

# Introduction
1. What is this project?
This report presented is to describe the overview, design, and implementation of a scheduling system that implements the Largest Round Robin algorithm whilst distributing jobs to servers in a simulated distributed system (provided by MQ University). The results generated by the use of this project are to be compared to a reference implementation (also provided by MQ University).

At it's core, a distributed system is a system that has various components which are spread across a network. This provides many advantages such as efficiency and redundancy, as well as introducing complications such as an increased complexity, synchonisation and replication. Example of a distributed system would be cloud computing (not all cloud computing is is an exmaple of distributed systems, you could just have one computer in the cloud), where thousands of computers can be used to handle complex tasks by breaking down jobs and handling them simulantously.

In a distributed system, the load is distributed across multiple machines to achieve results that are much faster and reliable than having one server that handles all requests. Each distributed system requires a mechanism to orchestrate and handle each request. This component is responsible for making scheduling decisions which may vary depending on the desired behaviour the algorithm.

This project acts as an orchestrating component of a distributed system.

What is the goal?
The goal for this project is to have a client (described below) which connects to the server (described below), receives jobs to be scheduled and makes scheduling decisions based on the desired algorithm (Largest Round Robin in this case). Once the server has run out of jobs to be processed, the client should gracefully disconnect from the server.


# System Overview 
The system is comprised of two main components:
1. the ds-sim Server (provided by MQ University) - the component intiates the request to process each job + the component that simulates the compute resources available.
2. the Client (this project) which is to be compared to the reference implementation (provided by MQ University) - the component that handles the request to process each job and selects compute resources on which to schedule jobs for processing.

The ds-sim server (1) simulates a distributed system. It is responsible for initiating the request to process a job, as well as providing the simulated compute resources (servers) on which each job may potentially be run. The purpose of the client (2) is to select the most appropriate simulated server on which the job should be processed.

The two components communicate via a Socket, which uses TCP at the network layer. See here \cite[https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html]

[INSERT DIAGRAM HERE]

The protocol is as follows:
1. the ds-sim server is started and waits for incoming socket connections
2. the client is started and initiates a handshake
3. once handshake is successful, the client sends REDY
4. the server responds with either:
    a. a new job
    b. a completed job
    c. an error
    d. a no new jobs command
5. the client handles as follows:
    a. selects the correct server to handle the job based on the LLR algorithm (after querying the system for a list of servers capable of handling the job)
    b. does not require handling
    c. ??
    d. closes the connection gracefully. 
6. steps 4 and 5 continue to occur until there are no longer any jobs left to process.

# Design
Our design needs to cater for the connection between the two main components, as well as break down the current state of the simulated system at any one time to handle incoming jobs. This is what is used to support the use of scheduling decisions that depend on knowing granular details on each of the following:
- the server
- each Job (including job ID, job type, number of cores required to run the job, etc)
- each Server in the simulated system (the server ID, server type, number of cores available, number of running jobs, etc)

What exactly is Largest Round Robin? How does it work?
A little bit about the Largest Round Robin algorithm. It works by scheduling jobs to servers that are of the type in the system have the highest number of cores. Eg, if there are a total of 5 servers: 1x supersilk (16 cores), 2x joon (12 cores), 2x juju (8 cores), the type of servers which the largest number of cores would be supersilk, even if at the time of job scheduling, there are more available cores on a joon server, as per largest round robin, the job should still be scheduled on the supersilk server. In this algorithm, all servers expect the ones of the largest type are ignored throughout the whole run.

The design achieves LLR by the use of the following components within the Client: (for later, rename the Client.java to Main.java or App.java)
1. A ConfigDataLoader 
2. A ClientServerConnection class
3. An Orchestrator class
4. A SimulatedSystem class
5. A SimulatedServer class
6. A JobInformationBuilder class
7. A JobInformation class
8. A Job class

Our design also needs to be easily extendible to support additional algorithms in the future. This meant that each of these components shouldn't make scheduling decisions themselves (implement the alorgithm), but rather, they should provide the tools for the task implementing the algorithm to make informed decisions.